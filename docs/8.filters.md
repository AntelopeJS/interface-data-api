# Filters

## Overview

The `@Filter` decorator allows you to add filtering capabilities to your Data API fields.
It enables you to filter list operations based on field values, providing powerful query capabilities
for your API endpoints.

## Basic Usage

### Default Filter

The simplest way to use `@Filter` is without any parameters, which creates a default filter
that supports basic comparison operations.

```typescript
import {Filter} from '@ajs/data-api/beta/metadata';

// Define your table
@RegisterTable('users')
class User extends Table {
  @Index({ primary: true })
  declare _id: string;

  declare email: string;
  declare age: number;
  declare is_active: boolean;
}
// Create your database model
class UserModel extends BasicDataModel(User, 'users') {}

@RegisterDataController()
class ProductAPI extends DataController(User, DefaultRoutes.All, Controller('/users')) {
    @ModelReference()
    @StaticModel(UserModel, database_name)
    declare userModel: UserModel;

    @Listable()
    @Access(AccessMode.ReadOnly)
    declare _id: string;

    @Listable()
    @Access(AccessMode.ReadWrite)
    @Filter()
    declare age: number;
    
    @Listable()
    @Access(AccessMode.ReadWrite)
    @Filter()
    declare is_active: boolean;
}
```

### Default Filter Operations

When using the default filter, you can use the following comparison operators:

- **`eq`** (default): Equal to
- **`ne`**: Not equal to
- **`gt`**: Greater than
- **`ge`**: Greater than or equal to
- **`lt`**: Less than
- **`le`**: Less than or equal to

### Query Parameters

Filters are applied using query parameters in the format:
```
filter_<fieldName>=<value>:<operator>
```

**Examples:**

Get users with age greater than 30:
```http
GET /users/list?filter_age=30:gt
```
Get active users:
```http
GET /users/list?filter_is_active=true
```
Get users with age lower than 25 and not active:
```http
GET /users/list?filter_age=25:lt&filter_is_active=false:ne
```

## Custom Filters

### Custom Filter Function

You can create custom filter functions for more complex filtering logic by providing a function
to the `@Filter` decorator. This function receives the request context, the row being filtered,
the field key, and the value to filter by.

The request used in the custom filter function should follow the database-decorators format,
see [Database Decorators](https://github.com/AntelopeJS/interface-database-decorators) for more details.

```typescript
function filterGmailAccounts(context: RequestContext, row: ValueProxy.Proxy<User>, key: string, value: any) {
  return row(key as keyof User).match('@gmail\\.com$'); // database-decorators compatible filter request
}

@RegisterDataController()
class ProductAPI extends DataController(User, DefaultRoutes.All, Controller('/users')) {
  @Listable()
  @Access(AccessMode.ReadWrite)
  @Filter(filterGmailAccounts)
  declare email: string;
  
  @Listable()
  @Access(AccessMode.ReadWrite)
  @Filter()
  declare age: number;
}
```

### Parameters

- **`context`**: The request context with additional `this` property containing the controller instance
- **`row`**: A proxy object representing the database row being filtered
- **`key`**: The field name being filtered
