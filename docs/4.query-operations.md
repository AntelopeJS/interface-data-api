# Query Operations

The Data API provides a set of query operations that make it easier to build endpoints. These operations are used internally by the default route handlers but can also be used in custom endpoints.

## Basic Query Operations

### Get

Creates a database query that retrieves a single record by ID:

```typescript
import { Query } from "@ajs/data-api/beta/components";
import { MyTable } from "db/t_my_table.ts";

// Inside a controller method
const record = await Query.Get(this.table, id);
```

You can also specify a secondary index:

```typescript
const record = await Query.Get(this.table, slug, "slug");
```

### List

Creates a database query that retrieves a list of records with support for sorting and filtering:

```typescript
import { Query } from "@ajs/data-api/beta/components";
import { MyTable } from "db/t_my_table.ts";

// Inside a controller method
const [query, total] = Query.List(
  this,
  meta,
  this.table,
  requestContext,
  ["price", "desc"], // Sort by price in descending order
  filters // Filters object
);

// Execute the query
const results = await query;
```

#### Filtering

The filters parameter accepts a structured object to filter results:

```typescript
const filters = {
  status: ["active", "eq"], // status equals 'active'
  priority: [3, "gt"], // priority greater than 3
};

const [query, total] = Query.List(
  this,
  meta,
  this.table,
  requestContext,
  ["price", "desc"],
  filters
);
```

The default field filter function supports the following operations:

- `eq` - Equals
- `ne` - Not equals
- `gt` - Greater than
- `ge` - Greater than or equal
- `lt` - Less than
- `le` - Less than or equal

### Delete

Creates a database query that deletes one or more records:

```typescript
import { Query } from "@ajs/data-api/beta/components";
import { MyTable } from "db/t_my_table.ts";

// Delete a single record
await Query.Delete(this.table, id);

// Delete multiple records
await Query.Delete(this.table, [id1, id2, id3]);
```

## Working with Foreign Keys

The Data API allows you to resolve foreign key references at query time using the `Query.Foreign` function. This function works on an existing record query containing reference IDs and replaces them with the corresponding complete objects.

### Why use Query.Foreign?

By default, a foreign key field (for example `user`) simply contains the referenced identifier:

```json
{
  "_id": "item123",
  "article": "Complete project",
  "user": "user456"
}
```

But by using `Query.Foreign`, you get the complete object instead of the ID:

```json
{
  "_id": "item123",
  "article": "Complete project",
  "user": {
    "_id": "user456",
    "name": "John Doe",
    "email": "john@example.com"
  }
}
```

### Example: resolving a foreign key on a get and on a list

```typescript
class MyDataAPIController {
  async getWithForeign(ctx: RequestContext, id: string) {
    const meta = GetDataControllerMeta(this);
    const query = Query.Get(this.table, id);
    const queryWithForeign = query.do((val) =>
      Query.Foreign(
        this.database,
        meta,
        val as ValueProxy.Proxy<Record<string, any>>
      )
    );
    const dbResult = await queryWithForeign;
    return dbResult;
  }

  async listWithForeign(ctx: RequestContext, filters: any) {
    const meta = GetDataControllerMeta(this);
    const [query, total] = Query.List(
      this,
      meta,
      this.table,
      ctx,
      ["price", "asc"],
      filters
    );
    const queryWithForeign = query.map((val) =>
      Query.Foreign(
        this.database,
        meta,
        val as ValueProxy.Proxy<Record<string, any>>
      )
    );
    const dbResult = await queryWithForeign;
    return dbResult;
  }
}
```

After these operations, all fields marked as foreign key are replaced by their complete object.

Each element of the `dbResult` array will have its foreign fields resolved.

## Property Reading and Writing

### ReadProperties

Processes fields and getters for API output:

```typescript
import { Query } from "@ajs/data-api/beta/components";
import { MyTable } from "db/t_my_table.ts";

// Inside a controller method
const dbResult = await Query.Get(this.table, id);
const record = await Query.ReadProperties(this, meta, dbResult);
```

The `ReadProperties` function applies:

1. Field access control (only readable fields)
2. Custom getter methods

### WriteProperties

Processes fields and setters for database input:

```typescript
import { Query } from "@ajs/data-api/beta/components";
import { MyTable } from "db/t_my_table.ts";

// Inside a controller method
const data = JSON.parse(requestBody);
const dbData = await Query.WriteProperties(this, meta, data);
await this.table.insert(dbData);
```

The `WriteProperties` function applies:

1. Field access control (only writable fields)
2. Custom setter methods

## Complete Examples

### Example 1: Custom List with Filtering and Sorting

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller("/my-endpoint")
) {
  @ModelReference()
  @StaticModel(MyTableModel, "default")
  declare model: MyTableModel;

  @Listable()
  @Sortable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Sortable()
  @Access(AccessMode.ReadWrite)
  declare article: string;

  @Listable()
  @Sortable()
  @Access(AccessMode.ReadWrite)
  declare price: number;

  @Foreign("users")
  declare user: User;

  // Custom endpoint to get items by price range
  async getItemsByPriceRange(
    @RequestContext() ctx: RequestContext,
    @Parameter("min", "query") minPrice: string,
    @Parameter("max", "query") maxPrice: string
  ) {
    const meta = GetDataControllerMeta(this);
    const model = Query.GetModel(this, meta);

    const filters = {
      price: [parseFloat(minPrice), "ge"],
      price2: [parseFloat(maxPrice), "le"],
    };

    const [query, total] = Query.List(
      this,
      meta,
      model.table,
      ctx,
      ["price", "asc"],
      filters
    );

    const results = await query;
    const processedResults = await Promise.all(
      results.map((result) =>
        Query.ReadProperties(this, meta, model.constructor.fromDatabase(result))
      )
    );

    Validation.ClearInternal(meta, processedResults);

    return {
      results: processedResults,
      total: await total,
    };
  }
}
```

### Example 2: Custom Get with Foreign Resolution

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller("/my-endpoint")
) {
  @ModelReference()
  @StaticModel(MyTableModel, "default")
  declare model: MyTableModel;

  @Listable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Access(AccessMode.ReadWrite)
  declare article: string;

  @Foreign("users")
  declare user: User;

  // Custom endpoint to get item with user details
  async getItemWithUser(
    @RequestContext() ctx: RequestContext,
    @Parameter("id", "query") id: string
  ) {
    const meta = GetDataControllerMeta(this);
    const model = Query.GetModel(this, meta);

    const query = Query.Get(model.table, id);
    const queryWithForeign = query.do((row) =>
      Query.Foreign(model.database, meta, row)
    );
    const record = await queryWithForeign;
    assert(record, "Item not found", 404);

    const result = await Query.ReadProperties(this, meta, record);
    Validation.ClearInternal(meta, result);

    return result;
  }
}
```

### Example 3: Custom Write with Validation

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller("/my-endpoint")
) {
  @ModelReference()
  @StaticModel(MyTableModel, "default")
  declare model: MyTableModel;

  @Listable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Mandatory("new", "edit")
  @Access(AccessMode.ReadWrite)
  @Validator((value: unknown) => typeof value === "string" && value.length >= 3)
  declare article: string;

  @Listable()
  @Mandatory("new", "edit")
  @Access(AccessMode.ReadWrite)
  @Validator((value: unknown) => typeof value === "number" && value > 0)
  declare price: number;

  // Custom endpoint to create item with validation
  async createItem(ctx: RequestContext, data: any) {
    const meta = GetDataControllerMeta(this);

    // Validate mandatory fields
    Validation.MandatoryFields(meta, data, "new");

    // Validate field types
    Validation.ValidateTypes(meta, data);

    const dbData = await Query.WriteProperties(this, meta, data);
    const model = Query.GetModel(this, meta);

    const result = await model.table.insert(dbData);
    return result.generated_keys;
  }
}
```

These examples demonstrate how to use the Query operations in different scenarios, from simple CRUD operations to complex filtering and validation. Each example shows a complete implementation that you can use as a reference for your own custom endpoints.
