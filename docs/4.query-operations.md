# Query Operations

The Data API provides a set of query operations that make it easy to work with database records. These operations are used internally by the default route handlers but can also be used in custom endpoints.

## Basic Query Operations

### Get

Retrieves a single record by ID:

```typescript
import { Query } from '@ajs/data-api/beta/components';
import { MyTable } from 'db/t_my_table.ts';

// Inside a controller method
const record = await Query.Get(this.table, id);
```

You can also specify a secondary index:

```typescript
const record = await Query.Get(this.table, slug, 'slug');
```

#### Response Format

The Get operation returns a database record object. When used in the default Get route, the record is processed through `ReadProperties` and `ClearInternal` before being sent to the client.

Example response:

```json
{
  "_id": "abc123",
  "article": "Sample Article",
  "price": 42
}
```

### List

Retrieves a list of records with support for sorting and filtering:

```typescript
import { Query } from '@ajs/data-api/beta/components';
import { MyTable } from 'db/t_my_table.ts';

// Inside a controller method
const [query, total] = Query.List(
  this,
  meta,
  this.table,
  requestContext,
  ["price", "desc"], // Sort by price in descending order
  filters // Filters object
);

// Execute the query
const results = await query;
```

#### List Response Format

When used in the default List route, the List operation returns an object with:

```json
{
  "results": [
    {
      "_id": "abc123",
      "article": "Record One",
      "price": 42
    },
    {
      "_id": "def456",
      "article": "Record Two",
      "price": 15
    }
  ],
  "total": 42,
  "offset": 0,
  "limit": 10
}
```

#### Advanced Filtering

The filters parameter accepts a structured object to filter results:

```typescript
const filters = {
  status: ['active', 'eq'], // status equals 'active'
  priority: [3, 'gt'], // priority greater than 3
};

const [query, total] = Query.List(
  this,
  meta,
  this.table,
  requestContext,
  ["price", "desc"],
  filters
);
```

Supported filter operations:

- `eq` - Equals
- `ne` - Not equals
- `gt` - Greater than
- `ge` - Greater than or equal
- `lt` - Less than
- `le` - Less than or equal

### Delete

Deletes a record or records:

```typescript
import { Query } from '@ajs/data-api/beta/components';
import { MyTable } from 'db/t_my_table.ts';

// Delete a single record
await Query.Delete(this.table, id);

// Delete multiple records
await Query.Delete(this.table, [id1, id2, id3]);
```

#### Delete Response

The Delete operation returns:

- For single delete: A boolean indicating success
- For multiple deletes: An object with counts of successful/failed deletions

## Working with Foreign Keys

The Data API allows you to resolve foreign key references at query time using the `Query.Foreign` function. This function takes a record containing reference IDs and replaces them with the corresponding complete objects.

### Why use Query.Foreign?

By default, a foreign key field (for example `user`) simply contains the referenced identifier:

```json
{
  "_id": "item123",
  "article": "Complete project",
  "user": "user456"
}
```

But by using `Query.Foreign`, you get the complete object instead of the ID:

```json
{
  "_id": "item123",
  "article": "Complete project",
  "user": {
    "_id": "user456",
    "name": "John Doe",
    "email": "john@example.com"
  }
}
```

### Example: resolving a foreign key on a get and on a list

```typescript
class MyDataAPIController {
  async getWithForeign(ctx: RequestContext, id: string) {
    const meta = GetDataControllerMeta(this);
    const dbResult = await Query.Get(this.table, id);
    const recordWithForeign = await Query.Foreign(this.database, meta, dbResult);
    return recordWithForeign;
  }

  async listWithForeign(ctx: RequestContext, filters: any) {
    const meta = GetDataControllerMeta(this);
    const [query, total] = Query.List(this, meta, this.table, ctx, ['price', 'asc'], filters);
    const results = await query;
    const resultsWithForeign = await Promise.all(
      results.map(result => Query.Foreign(this.database, meta, result))
    );
    return resultsWithForeign;
  }
}
```

After these operations, all fields marked as foreign key in the model are replaced by their complete object.

Each element of the `resultsWithForeign` array will have its foreign fields resolved.

### Summary

- Use `Query.Foreign(database, meta, record)` to replace IDs with complete objects.
- This works both on a single object and on a list.
- You can chain with `Query.ReadProperties` to get the final format for the API.

## Property Reading and Writing

### ReadProperties

Processes fields for API output:

```typescript
import { Query } from '@ajs/data-api/beta/components';
import { MyTable } from 'db/t_my_table.ts';

// Inside a controller method
const dbResult = await Query.Get(this.table, id);
const record = await Query.ReadProperties(this, meta, dbResult);
```

The `ReadProperties` function applies:

1. Field access control (only readable fields)
2. Custom getter methods
3. Field transformations

### WriteProperties

Processes fields for database input:

```typescript
import { Query } from '@ajs/data-api/beta/components';
import { MyTable } from 'db/t_my_table.ts';

// Inside a controller method
const data = JSON.parse(requestBody);
const dbData = await Query.WriteProperties(this, meta, data);
await this.table.insert(dbData);
```

The `WriteProperties` function applies:

1. Field access control (only writable fields)
2. Custom setter methods
3. Field validation
4. Field transformations

## Complete Examples

### Example 1: Custom List with Filtering and Sorting

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Listable()
  @Sortable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Sortable()
  @Access(AccessMode.ReadWrite)
  declare article: string;

  @Listable()
  @Sortable()
  @Access(AccessMode.ReadWrite)
  declare price: number;

  @Foreign('users')
  declare user: User;

  // Custom endpoint to get items by price range
  async getItemsByPriceRange(ctx: RequestContext, minPrice: number, maxPrice: number) {
    const meta = GetDataControllerMeta(this);
    const model = Query.GetModel(this, meta);

    const filters = {
      price: [minPrice, 'ge'],
      price2: [maxPrice, 'le']
    };

    const [query, total] = Query.List(
      this,
      meta,
      model.table,
      ctx,
      ['price', 'asc'],
      filters
    );

    const results = await query;
    const processedResults = await Promise.all(
      results.map(result => Query.ReadProperties(this, meta, result))
    );

    Validation.ClearInternal(meta, processedResults);

    return {
      results: processedResults,
      total: await total
    };
  }
}
```

### Example 2: Custom Get with Foreign Resolution

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Listable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Access(AccessMode.ReadWrite)
  declare article: string;

  @Foreign('users')
  declare user: User;

  // Custom endpoint to get item with user details
  async getItemWithUser(ctx: RequestContext, id: string) {
    const meta = GetDataControllerMeta(this);
    const model = Query.GetModel(this, meta);

    const record = await Query.Get(model.table, id);
    assert(record, 'Item not found', 404);

    const recordWithUser = await Query.Foreign(
      model.database,
      meta,
      record
    );

    const result = await Query.ReadProperties(this, meta, recordWithUser);
    Validation.ClearInternal(meta, result);

    return result;
  }
}
```

### Example 3: Custom Write with Validation

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Listable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Mandatory('new', 'edit')
  @Access(AccessMode.ReadWrite)
  @Validator((value: unknown) => typeof value === 'string' && value.length >= 3)
  declare article: string;

  @Listable()
  @Mandatory('new', 'edit')
  @Access(AccessMode.ReadWrite)
  @Validator((value: unknown) => typeof value === 'number' && value > 0)
  declare price: number;

  // Custom endpoint to create item with validation
  async createItem(ctx: RequestContext, data: any) {
    const meta = GetDataControllerMeta(this);
    
    // Validate mandatory fields
    Validation.MandatoryFields(meta, data, 'new');
    
    // Validate field types
    Validation.ValidateTypes(meta, data);

    const dbData = await Query.WriteProperties(this, meta, data);
    const model = Query.GetModel(this, meta);
    
    const result = await model.table.insert(dbData);
    return result.generated_keys;
  }
}
```

### Example 4: Complex Filter Implementation

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Listable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Access(AccessMode.ReadWrite)
  declare article: string;

  @Listable()
  @Access(AccessMode.ReadWrite)
  declare price: number;

  @Foreign('users')
  declare user: User;

  // Custom filter for price range and user
  static priceAndUserFilter: FilterFunction<MyDataAPI> = (
    context,
    row,
    key,
    value,
    mode
  ) => {
    const [minPrice, maxPrice, userId] = value.split(',');
    return row('price')
      .ge(Number(minPrice))
      .and(row('price').le(Number(maxPrice)))
      .and(row('user').eq(userId));
  };

  // Custom endpoint using the filter
  async getFilteredItems(ctx: RequestContext, filterValue: string) {
    const meta = GetDataControllerMeta(this);
    const model = Query.GetModel(this, meta);

    const filters = {
      priceAndUser: [filterValue, 'custom']
    };

    const [query, total] = Query.List(
      this,
      meta,
      model.table,
      ctx,
      ['price', 'asc'],
      filters
    );

    const results = await query;
    const processedResults = await Promise.all(
      results.map(result => Query.ReadProperties(this, meta, result))
    );

    Validation.ClearInternal(meta, processedResults);

    return {
      results: processedResults,
      total: await total
    };
  }
}
```

These examples demonstrate how to use the Query operations in different scenarios, from simple CRUD operations to complex filtering and validation. Each example shows a complete implementation that you can use as a reference for your own custom endpoints.