# Data Controllers

Data controllers are specialized API controllers designed to handle database operations for specific tables. They provide a streamlined way to create RESTful CRUD endpoints for your data models.

## Creating a Data Controller

To create a data controller, you need to use the `DataController` function and the `RegisterDataController` decorator:

```typescript
import {
  DataController,
  DefaultRoutes,
  RegisterDataController,
} from '@ajs/data-api/beta';
import { MyTable } from 'db/t_my_table.ts';

export namespace MyDataAPI {
  @RegisterDataController()
  export class MyController extends DataController(
    MyTable,
    DefaultRoutes.All,
    Controller('/my-endpoint')
  ) {
    // Field definitions and customizations go here
  }
}
```

The `DataController` function takes three arguments:
1. The table class for your data model (e.g., `MyTable`)
2. Route definitions (usually from `DefaultRoutes`)
3. The base endpoint path (e.g., "/my-endpoint")

The Data API provides a set of predefined routes in `DefaultRoutes.All` that you can use:
- `DefaultRoutes.Get` - GET `/:id` - Get a single record
- `DefaultRoutes.List` - GET `/` - List records
- `DefaultRoutes.New` - POST `/` - Create a new record
- `DefaultRoutes.Edit` - PUT `/:id` - Update a record
- `DefaultRoutes.Delete` - DELETE `/:id` - Delete a record

You can use all of them with `DefaultRoutes.All` or pick only the ones you need:

```typescript
// Using all default routes
DataController(MyTable, DefaultRoutes.All, Controller('/my-endpoint'))

// Using only specific routes
DataController(MyTable, {
  get: DefaultRoutes.Get,
  list: DefaultRoutes.List
}, Controller('/my-endpoint'))
```

## Default Routes

The Data API provides a set of default route handlers for common CRUD operations:

- **Get**: Retrieves a single record by ID
- **List**: Returns a paginated list of records with optional sorting and filtering
- **New**: Creates a new record
- **Edit**: Updates an existing record
- **Delete**: Removes one or more records

### Default Routes in Detail

Each default route has specific HTTP methods, parameters, and response formats:

#### Get Route

- **HTTP Method**: GET
- **Endpoint**: `/:id`
- **Query Parameters**:
  - `noForeign` (optional): Set to skip foreign key resolution
- **Response Format**: Single record object
- **Status Codes**:
  - 200: Success
  - 404: Record not found
  - 400: Bad request (invalid ID)

#### List Route

- **HTTP Method**: GET
- **Endpoint**: `/`
- **Query Parameters**:
  - `offset` (optional): Pagination offset (default: 0)
  - `limit` (optional): Number of items per page (default: 10, max: 100)
  - `sortKey` (optional): Field to sort by
  - `sortDirection` (optional): Sort direction ('asc' or 'desc')
  - `filter_[fieldName]`: Filter criteria (e.g., `filter_status=eq:active`)
  - `noForeign` (optional): Set to skip foreign key resolution
  - `noPluck` (optional): Set to include all fields
  - `pluckMode` (optional): Pluck mode to use (default: 'list')
- **Response Format**:
  ```typescript
  {
    results: Record<string, any>[],  // Array of records
    total: number,                   // Total count
    offset: number,                  // Current offset
    limit: number                    // Current limit
  }
  ```

  Example:
  ```shell
  curl -X GET "http://localhost:3000/api/my-endpoint?offset=0&limit=10&sortKey=createdAt&sortDirection=desc&filter_status=eq:active&noForeign=true"
  ```

  Example:
  ```json
  {
    "results": [
      {
        "_id": "123",
        "article": "Example Item",
        "price": 12
      },
      {
        "_id": "124",
        "article": "Another Item",
        "price": 15
      },
    ],
    "total": 42,
    "offset": 0,
    "limit": 10
  }
  ```

#### New Route

- **HTTP Method**: POST
- **Endpoint**: `/`
- **Request Body**: JSON object with field values
- **Query Parameters**:
  - `noMandatory` (optional): Skip mandatory field validation
- **Response Format**: Array of generated IDs
- **Status Codes**:
  - 200: Success
  - 400: Bad request (validation error)

#### Edit Route

- **HTTP Method**: PUT
- **Endpoint**: `/:id`
- **Request Body**: JSON object with field values to update
- **Query Parameters**:
  - `noMandatory` (optional): Skip mandatory field validation
- **Response Format**: Empty success response
- **Status Codes**:
  - 200: Success
  - 404: Record not found
  - 400: Bad request (validation error)

#### Delete Route

- **HTTP Method**: DELETE
- **Endpoint**: `/:id`
- **Query Parameters**:
  - Multiple IDs can be specified as repeated query parameters: `?id=123&id=456`
- **Response Format**: Boolean success indicator
- **Status Codes**:
  - 200: Success
  - 404: Record not found

## Customizing Default Routes

You can customize default routes using the `WithOptions` function:

```typescript
export namespace MyDataAPI {
  @RegisterDataController()
  export class MyController extends DataController(
    MyTable,
    {
      list: DefaultRoutes.WithOptions(DefaultRoutes.List, {
        limit: 20,
        maxPage: 50,
        noForeign: true,
        pluckMode: 'detailed'
      }),
    },
    Controller('/my-endpoint')
  ) {
    // Field definitions...
  }
}
```

## Multiple List Modes
Multiple list modes allow you to define different views of your data for different use cases. This is particularly useful when you need to:

- Show different fields in different contexts (e.g., a compact list vs. a detailed view)
- Optimize API responses by only returning necessary fields
- Create specialized views for different user roles or features

For example, you might want:
- A compact list for search results showing only essential fields
- A detailed list for admin views with additional metadata
- A summary list for dashboard widgets with aggregated data

Each list mode can have its own set of fields, defined using the `@Listable` decorator with a mode parameter. Fields can be included in multiple modes by applying the decorator multiple times.

The example below shows how to create two different list views - a basic list and a detailed list:

```typescript
export namespace MyDataAPI {
  @RegisterDataController()
  export class MyController extends DataController(
    MyTable,
    {
      list: DefaultRoutes.List,
      list2: DefaultRoutes.WithOptions(DefaultRoutes.List, { pluckMode: 'list2' }),
    },
    Controller('/my-endpoint')
  ) {
    @Listable()
    @Listable(true, 'list2')
    declare _id: string;

    @Listable()
    declare article: string;

    @Listable(true, 'list2')
    declare price: number;
  }
}
```

## Custom List Implementation
Custom list implementations are useful for:
- Adding computed fields (e.g. fullName from firstName + lastName)
- Modifying response format
- Implementing custom filtering
- Adding data aggregation
- Transforming data before sending to client


You can create custom list implementations by extending the default list functionality:

```typescript
export namespace MyDataAPI {
  export class CustomList {
    async myList(ctx: RequestContext, listParams: Parameters.ListParameters) {
      const res = await DefaultRoutes.List.func(ctx, listParams);
      for (const obj of res.results) {
        obj.extraField = 'hello';
      }
      return res;
    }
  }

  export const MyList = { 
    func: CustomList.prototype.myList, 
    args: [Context(), Parameters.List()], 
    method: 'get' 
  };

  @RegisterDataController()
  export class MyController extends DataController(
    MyTable,
    {
      list: DefaultRoutes.List,
      list2: MyList,
    },
    Controller('/my-endpoint')
  ) {
    // Field definitions...
  }
}
```
