# Data Metadata

The Data API module uses metadata decorators to configure how fields are handled, processed, and exposed through the API. These decorators are applied to class properties in your data controller.

## Field Access Control

Control whether fields can be read from or written to using the `Access` decorator:

```typescript
import { Access, AccessMode } from '@ajs/data-api/beta/metadata';
import { MyTable } from 'db/t_my_table.ts';

@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Access(AccessMode.WriteOnly)
  declare price: string;

  @Access(AccessMode.ReadWrite)
  declare article: string;

  @Access(AccessMode.ReadWrite)
  declare user: string;
}
```

Available access modes:

- `AccessMode.ReadOnly`: Field can be read but not written
- `AccessMode.WriteOnly`: Field can be written but not read
- `AccessMode.ReadWrite`: Field can be both read and written

## Listing and Sorting

The `Listable` decorator controls which fields appear in the responses of list endpoints (`list`, or any endpoint using the corresponding pluck mode). It helps optimize API responses by only returning the necessary fields depending on the context or display mode.

### Correct usage

- `@Listable()`: the field will be included in the default list (mode 'list')
- `@Listable(true, 'detailed')`: the field will be included only in the 'detailed' mode
- To include a field in multiple modes, apply the decorator multiple times:
  ```typescript
  @Listable(true, 'list')
  @Listable(true, 'detailed')
  declare article: string;
  ```

### Examples

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  // Appears in the default list
  @Listable()
  declare article: string;

  // Appears only in the 'detailed' mode
  @Listable(true, 'detailed')
  declare metadata: string;

  // Appears in both 'list' and 'detailed' modes
  @Listable(true, 'list')
  @Listable(true, 'detailed')
  declare price: number;
}
```

### What does `Listable` actually do?

- It tells the DataController which fields should be extracted and returned in list endpoint responses.
- It allows you to define view modes (for example: a compact view for search, a detailed view for admin, etc.).
- It optimizes performance by avoiding sending unnecessary fields depending on the context.

### Concrete use cases

- **Compact list for search**:
  ```typescript
  @Listable(true, 'search')
  declare article: string;
  ```
  → The endpoint `/my-endpoint?pluckMode=search` will only return `article` and `price`.
  Example response:
  ```json
  [
    { "article": "Item A"},
    { "article": "Item B"}
  ]
  ```

- **Detailed view**:
  ```typescript
  @Listable(true, 'detailed')
  declare _id: string;
  @Listable(true, 'detailed')
  declare article: string;
  @Listable(true, 'detailed')
  declare price: number;
  ```
  → The endpoint `/my-endpoint?pluckMode=detailed` will return `_id`, `article`, and `price`.
  Example response:
  ```json
  [
    { "_id": "1", "article": "Item A", "price": 10 },
    { "_id": "2", "article": "Item B", "price": 15 }
  ]
  ```

- **Default view**:
  ```typescript
  @Listable()
  declare article: string;
  @Listable()
  declare price: number;
  ```
  → The endpoint `/my-endpoint` (without pluckMode) will return only `article` and `price`.
  Example response:
  ```json
  [
    { "article": "Item A", "price": 10 },
    { "article": "Item B", "price": 15 }
  ]
  ```

**Note:** Each mode (`list`, `detailed`, `search`, etc.) defines its own set of fields. Switching the mode does not simply add fields to the default view, but selects a different set of fields for the response.

In summary, `Listable` allows you to dynamically adapt the structure of list responses to business needs or user interface requirements.

### Example: Multiple list modes

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Listable(true, 'detailed')
  declare _id: string;

  @Listable(true, 'search')
  @Listable(true, 'detailed')
  declare article: string;
  
  @Listable(true, 'detailed')
  declare price: number;
}
```

- **Result for `/my-endpoint?pluckMode=search`**
```json
[
  { "article": "Item A" },
  { "article": "Item B" }
]
```

- **Result for `/my-endpoint?pluckMode=detailed`**
```json
[
  { "_id": "1", "article": "Item A", "price": 10 },
  { "_id": "2", "article": "Item B", "price": 15 }
]
```

## Mandatory Fields

The `@Mandatory` decorator is used to specify which fields is required for certain operations.

Example usage:

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Mandatory('new', 'edit') // Required for both new and edit operations
  declare article: string;

  @Mandatory('new') // Only required for new operations
  declare initialStatus: string;
}
```

Here, a newly created record must have both `article` and `initialStatus` fields, while updates only require the `article` field to be present. If not, the request will be rejected.

## Foreign Key References

Define relationships between data models:

```typescript
interface User {
  _id: string;
  name: string;
}

@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Foreign('users') // Reference to the users table
  declare user: User;

  @Foreign('categories', 'slug') // Reference to categories table, using slug as the index
  declare categorySlug: string;

  @Foreign('tags', undefined, true) // Multiple references to tags table
  declare tagIds: string[];
}
```

## Model Reference

Connect your data controller to a model instance:

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @ModelReference()
  @StaticModel(MyTableModel, 'default')
  declare myTableModel: MyTableModel;
}
```

## Custom Validation

Add custom validation for field values:

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Validator((value: unknown) => typeof value === 'string' && value.length >= 3)
  declare article: string;
}
```

## Combining Decorators

Decorators can be combined to create powerful field configurations:

```typescript
@RegisterDataController()
export class MyDataAPI extends DataController(
  MyTable,
  DefaultRoutes.All,
  Controller('/my-endpoint')
) {
  @Listable()
  @Sortable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Sortable()
  @Mandatory('new', 'edit')
  @Access(AccessMode.ReadWrite)
  @Validator((value: unknown) => typeof value === 'string' && value.length >= 3)
  declare article: string;

  @Listable()
  @Access(AccessMode.ReadWrite)
  declare description: string;

  @Listable()
  @Sortable()
  @Foreign('users')
  @Access(AccessMode.ReadOnly)
  declare user: User;
}
```

## Field Definitions Inheritance

Field definitions are inherited from parent classes, allowing for reuse of common field definitions:

```typescript
@RegisterDataController()
export class BaseDataAPI extends DataController(
  BaseTable,
  DefaultRoutes.All,
  Controller('/base')
) {
  @Listable()
  @Sortable()
  @Access(AccessMode.ReadOnly)
  declare _id: string;

  @Listable()
  @Sortable()
  @Access(AccessMode.ReadOnly)
  declare createdAt: Date;
}

@RegisterDataController()
export class MyDataAPI extends BaseDataAPI {
  // Inherits _id and createdAt definitions from BaseDataAPI

  @Listable()
  @Mandatory('new', 'edit')
  @Access(AccessMode.ReadWrite)
  declare article: string;
}
```
