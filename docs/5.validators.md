# Validators

## Overview

Validators in the Data API framework provide field-level validation to ensure data integrity
and business rule compliance. The `@Validator` decorator allows you to define custom
validation functions that are automatically executed during create and update operations.

## Basic Usage

### Simple Validation

The `@Validator` decorator accepts a function that takes a value and returns a boolean indicating
whether the value is valid.

```typescript
import { Validator } from '@ajs/data-api/beta/metadata';

const validateNumberGreaterThan = (value: any, min: number) => {
  return (value) => typeof value === 'number' && value > min;
}

@RegisterDataController()
class UserAPI extends DataController(User, DefaultRoutes.All, Controller('/users')) {
  @Validator((value) => typeof value === 'string' && value.trim().length > 0)
  declare name: string;

  @Validator((value) => validateNumberGreaterThan(value, 0))
  declare age: number;
}
```

### Validation Function Signature

```typescript
type ValidatorFunction = (value: unknown) => boolean;
```

The validation function:
- Receives the field value as input
- Returns `true` if the value is valid
- Returns `false` if the value is invalid
- Should handle different data types gracefully

## Common Validation Patterns

### String Validation

```typescript
// String length validation
@Validator((value) => typeof value === 'string' && value.length >= 2)
declare firstName: string;

// Email format validation
const emailRegex = /^(?!.*\.\.)[\w](\.?[\w-]+)*@(?:[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\.)+[a-zA-Z]{2,}$/;
@Validator((value) => typeof value === 'string' && emailRegex.test(value))
declare title: string;
```

### Number Validation

```typescript
// Range validation
@Validator((value) => typeof value === 'number' && value >= 0 && value <= 120)
declare age: number;

// Integer validation
@Validator((value) => typeof value === 'number' && Number.isInteger(value))
declare quantity: number;
```

### Date Validation

```typescript
// Valid date string
@Validator((value) => typeof value === 'string' && !isNaN(Date.parse(value)))
declare birthDate: Date;

// Future date only
@Validator(value => typeof value === 'string' && !isNaN(Date.parse(value)) && new Date(value) > new Date())
declare appointmentDate: Date;
```

## Advanced Validation Patterns

### Conditional Validation

```typescript
// Email is required only if user is active
@Validator((value, context) => {
  const isActive = context.isActive;
  if (isActive && (!value || typeof value !== 'string')) return false;
  if (value && typeof value === 'string') {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  }
  return true;
})
declare email: string;
```

### Cross-Field Validation

```typescript
// End date must be after start date
@Validator((value, context) => {
  if (!value || typeof value !== 'string') return false;
  const endDate = new Date(value);
  const startDate = new Date(context.startDate);
  return endDate > startDate;
})
declare endDate: Date;
```

## Mandatory Fields

The `@Mandatory` decorator allows you to specify which fields are required for specific operations.
Unlike `@Validator` which validates field content, `@Mandatory` only ensures that fields are present in the request.

### Basic Usage

```typescript
import { Mandatory } from '@ajs/data-api/beta/metadata';

@RegisterDataController()
class UserAPI extends DataController(User, DefaultRoutes.All, Controller('/users')) {
  // Model reference

  @Mandatory('new', 'edit')  // Required for both create and update operations
  declare email: string;

  @Mandatory('new')          // Required only for create operations
  declare password: string;

  @Mandatory('edit')         // Required only for update operations
  declare status: string;

  declare notes: string;     // Not mandatory for any operation
}
```
### Skipping Mandatory Validation

You can disable mandatory field validation for specific routes using the `noMandatory` option:

```typescript
const customRoutes = {
  edit: DefaultRoutes.Edit,
  editNoMandatory: DefaultRoutes.WithOptions(DefaultRoutes.Edit, { noMandatory: 'true' })
};

@RegisterDataController()
class UserAPI extends DataController(User, customRoutes, Controller('/users')) {
  @Mandatory('edit')
  declare status: string;
}
```

The request to `/users/edit` will fail if the `status` field is missing, while the request to `/users/editNoMandatory` 
will not enforce this validation.

## Error Handling

When validation fails:

1. **HTTP Status**: Returns `400 Bad Request`
2. **Error Message**: Includes field name and validation details
3. **Partial Validation**: All fields are validated, but only the first error is reported

Be aware that the error is returned in **plaintext**, not json format.

## TODO: THE ERROR SHOULD BE IN JSON FORMAT SO A JSON PARSE DONT FAIL

## Continuing with listable fields
See the [listable fields documentation](./6.listable.md) to learn how to manage field visibility in list and pagination operations.